\chapter{\textsf{R} et les séries chronologiques}
\index{series@séries chronologiques|(}
\index{series@séries chronologiques|seealso{processus}}
\label{chap:ts}

<<echo=FALSE>>=
options(width=55)
@

<<echo=FALSE>>=
### Chargement des jeux de données
deaths <- ts(scan("deaths.dat", comment.char="#"), start = 1973, frequency = 12)
strikes <- ts(scan("strikes.dat", comment.char="#"), start = 1951)
@

\textsf{R} offre toutes les fonctions nécessaires pour faire l'analyse
complète de séries chronologiques: création et manipulation d'objets
de classe «série chronologique», identification et définition d'un
modèle, estimation des paramètres, calcul de prévisions et simulation
de séries. La liste des principales fonctions utilisées pour l'analyse
de séries chronologiques se trouve au tableau \ref{tab:ts:fonctions}.
Quelques autres fonctions sont disponibles, notamment pour le
traitement des séries multivariées; voir \citet[chapitre 14]{MASS}.

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    \textbf{Phase de l'analyse} & \textbf{Fonctions} \\
    \midrule
    Création et manipulation de séries
    & \fonction{ts}, \fonction{rts}, \fonction{cts}, \fonction{its} \\
    & \fonction{time} \\
    & \fonction{start} \\
    & \fonction{end} \\
    & \fonction{frequency} \\
    & \fonction{cycle} \\
    & \fonction{window} \\
    & \fonction{diff} \\
    & \fonction{filter} \\
    & \fonction{stl} \\
    \midrule
    Identification
    & \fonction{plot}, \fonction{ts.plot} \\
    & \fonction{acf} \\
    & \fonction{pacf} \\
    \midrule
    Estimation
    & \fonction{ar} \\
    & \fonction{arima} \\
    & \fonction{ARMAacf} \\
    & \fonction{ARMAtoMA} \\
    \midrule
    Diagnostics
    & \fonction{tsdiag} \\
    \midrule
    Calcul de prévisions
    & \fonction{predict} \\
    \midrule
    Simulation
    & \fonction{arima.sim} \\
    \bottomrule
  \end{tabular}
  \caption{Principales fonctions \textsf{R} pour l'analyse de séries
    chronologiques}
  \label{tab:ts:fonctions}
\end{table}


\section{Importation des données}
\index{series@séries chronologiques!importation de données}
\label{chap:ts:importation}

Les séries chronologiques sont typiquement créées à partir de vecteurs
simples. Or, la fonction \Fonction{scan} lit justement l'intégralité
des données du fichier dont le nom est donné en premier argument, puis
retourne un vecteur. Elle constitue donc le meilleur choix pour
importer des séries chronologiques dans \textsf{R}.

Contrairement à \fonction{read.table}, la fonction \code{scan} ne
reconnaît pas les commentaires par défaut. Toutefois, il suffit de
spécifier le caractère représentant le début d'un commentaire avec
l'argument \code{comment.char}.


\section{Création et manipulation de séries}
\index{series@séries chronologiques!création}
\label{chap:ts:creation}

La façon la plus simple de créer des séries chronologiques est
d'utiliser la fonction \Fonction{ts}. Les fonctions \fonction{rts}
(séries régulières), \fonction{cts} (séries avec dates) et
\fonction{its} (séries irrégulières) sont plus récentes et parfois
nécessaires.

La fonction \Fonction{window} permet d'extraire un sous-ensemble d'une
série chronologique en spécifiant des dates de début et de fin plutôt
que des positions dans le vecteur des observations.


\section{Identification}
\index{series@séries chronologiques!identification}
\label{chap:ts:identification}

La première chose à faire dans l'analyse d'une série chronologique
consiste à tracer le graphique de la série et son
corrélogramme\index{corrélogramme}. Le premier graphique est obtenu
avec la fonction spécialisée \fonction{ts.plot} ou, plus simplement,
avec \fonction{plot}.

La fonction \Fonction{acf} peut calculer et tracer les fonctions
(échantillonnales) d'autocovariance\index{autocovariance}
$\hat{\gamma}_X(h)$, d'autocorrélation\index{autocorrélation}
$\hat{\rho}_X(h)$ ou d'autocorrélation
partielle\index{autocorrélation!partielle} $\hat{\phi}_{hh}$ selon la
valeur de son argument \code{type} (spécifier \code{covariance},
\code{correlation} et \code{partial}, respectivement). Par défaut,
\code{acf} trace le corrélogramme de la série. Si l'on souhaite
obtenir les valeurs de la fonction d'autocorrélation sans graphique,
ajouter l'option \code{plot = FALSE} dans l'appel de la fonction.

La fonction d'autocorrélation partielle s'obtient aussi plus
directement avec la fonction \Fonction{pacf}.


\section{Estimation}
\index{series@séries chronologiques!estimation}
\label{chap:ts:modelisation}

Un processus ARMA\index{processus!ARMA} d'ordre $(p, q)$ est défini
comme la solution $\{X_t\}$ des équations
\begin{displaymath}
  \phi(B) X_t  = \theta(B) Z_t, \quad t = 0, \pm 1, \pm 2, \dots
\end{displaymath}
où
\begin{align*}
  \phi(z)   &= 1 - \phi_1 z - \dots - \phi_p z^p \\
  \theta(z) &= 1 + \theta_1 z + \dots + \theta_q z^q,
\end{align*}
$BX_t = X_{t-1}$ et $\{Z_t\} \sim \text{WN}(0, \sigma^2)$. C'est là
précisément la paramétrisation retenue dans \textsf{R}.

Un processus ARIMA\index{processus!ARIMA} est un processus
non stationnaire qui, une fois la $d${\ieme} différence appliquée sur
la série, est un processus ARMA.  Autrement dit, $\{X_t\} \sim
\text{ARIMA}(p, d, q)$ si $\{\nabla^d X_t\} \sim \text{ARMA}(p, q)$ et
donc $\{X_t\}$ est la solution stationnaire de
\begin{displaymath}
  \phi(B) (1 - B)^d X_t  = \theta(B) Z_t.
\end{displaymath}

L'étape de la modélisation consiste donc à ajuster un modèle ARIMA aux
observations d'une série chronologique en estimant les paramètres
$\phi_1, \dots, \phi_p$, $\theta_1, \dots, \theta_q$ et $\sigma^2$.
C'est le rôle des fonctions \code{ar} et \code{arima}.

La fonction \Fonction{ar} est très pratique pour une première
estimation: elle ajuste un modèle AR$(p)$ aux données pour plusieurs
valeurs de $p$ à l'aide des équations de Yule--Walker (par défaut) et
retourne le modèle avec la plus faible statistique AIC. Cette
statistique est égale à moins deux fois la fonction de
log-vraisemblance pénalisée par le nombre de paramètres dans le
modèle.

D'autre part, la fonction \Fonction{arima} estime les paramètres d'un
modèle ARIMA d'ordre $(p, d, q)$ par la technique du maximum de
vraisemblance (par défaut).  Contrairement à \code{ar}, la fonction
\code{arima} ne fait pas un choix parmi plusieurs modèles --- il y en
aurait beaucoup trop. Il faut donc spécifier les valeurs de $p$, $d$
et $q$ à l'aide de l'argument \argument{order} (un vecteur de trois
éléments). À noter que la fonction \code{arima} inclut une moyenne
$\mu$ dans le modèle lorsque $d = 0$.

Finalement, les séries comportant de la saisonnalité sont modélisées à
l'aide des très généraux processus SARIMA\index{processus!SARIMA}. Le
processus SARIMA d'ordre $(p, d, q) \times (P, D, Q)_s$ est défini
comme la solution stationnaire $\{X_t\}$ des équations
\begin{displaymath}
  \phi(B) \Phi(B^s) W_t = \theta(B) \Theta(B^s) Z_t, \quad
  W_t = \nabla^d \nabla_s^D X_t,
\end{displaymath}
où
\begin{align*}
  \phi(z)   &= 1 - \phi_1 z - \dots - \phi_p z^p \\
  \Phi(z)   &= 1 - \Phi_1 z - \dots - \Phi_P z^P \\
  \theta(z) &= 1 + \theta_1 z + \dots + \theta z^q \\
  \Theta(z) &= 1 + \Theta_1 z + \dots + \Theta_Q z^Q
\end{align*}
et $\{Z_t\} \sim \text{WN}(0, \sigma^2)$.

Les paramètres d'un modèle SARIMA sont toujours estimés à l'aide de la
fonction \fonction{arima} en spécifiant les valeurs de $P$, $D$, $Q$ et
$s$ par l'argument \argument{seasonal}.

La fonction \Fonction{ARMAacf} permet de calculer la fonction
d'autocorrélation\index{autocorrélation} ou d'autocorrélation
partielle\index{autocorrélation!partielle} théorique d'un processus
ARMA quelconque. La fonction \Fonction{ARMAtoMA}, comme son nom
l'indique, permet quant à elle
d'inverser\index{processus!ARMA!inversion} un processus ARMA
quelconque. Toutes deux peuvent s'avérer utiles pour vérifier ses
calculs.


\section{Diagnostics}
\index{series@séries chronologiques!diagnostics}
\label{chap:ts:diagnostics}

La fonction \Fonction{tsdiag} permet de juger rapidement de la qualité
d'ajustement d'un modèle. La fonction crée trois graphiques: la série
des résidus $\{Z_t\}$, le corrélogramme\index{corrélogramme} de cette
même série et un graphique de la valeur $p$ de la statistique de
Ljung--Box pour des valeurs de $H = 1, 2, \dots$ La statistique de
Ljung--Box\index{Ljung--Box} est simplement une version améliorée de
la statistique du test portmanteau\index{portmanteau}:
\begin{displaymath}
  Q_{LB} = n(n + 2) \sum_{h=1}^H \frac{\hat\rho^2(h)}{n - h}.
\end{displaymath}

Si l'ajustement du modèle est bon, les résidus forment un bruit blanc.
Le corrélogramme généré par \fonction{tsdiag} devrait donc ressembler
à celui d'un bruit blanc et les valeurs $p$ devraient être grandes (on
ne rejette pas l'hypothèse de bruit blanc).


\section{Calcul de prévisions}
\index{series@séries chronologiques!prévisions}
\label{chap:ts:previsions}

La prévision de modèles ARIMA repose sur une méthode de la fonction
générique \fonction{predict} pour les objets de classe \classe{Arima}
(créés par la fonction \fonction{arima}). Les prévisions sont donc
calculées exactement comme en régression, outre que l'argument
principal de \fonction{predict} devient le nombre de périodes pour
lesquelles l'on veut une prévision, et non les valeurs d'une ou
plusieurs variables indépendantes. L'écart type de chaque prévision
est également calculé par \fonction{predict}, ce qui permet de
calculer des bornes d'intervalles de prévision.


\section{Simulation}
\index{series@séries chronologiques!simulation}
\label{chap:ts:simulation}

La simulation de séries chronologiques ARIMA est très simple avec la
fonction \Fonction{arima.sim}. Il suffit de savoir comment spécifier
le modèle à simuler. L'argument \argument{model} de la fonction
\code{arima.sim} est une liste comportant un ou plusieurs des éléments
\code{ar}, \code{ma} et \code{order}. Le premier de ces éléments est
le vecteur des paramètres $\phi_1, \dots, \phi_p$; le second, le
vecteur des paramètres $\theta_1, \dots, \theta_q$; le troisième, le
vecteur $(p, d, q)$ --- utilisé seulement si $d > 0$.

Par défaut, le bruit blanc est généré avec une loi normale centrée
réduite. On peut changer la distribution à utiliser avec l'argument
\code{rand.gen} ou passer des arguments différents à la fonction de
simulation du bruit blanc directement dans l'appel de
\code{arima.sim}. Voir les exemples à la section \ref{chap:ts:exemples}.

\index{series@séries chronologiques|)}

\section{Exemples}
\label{chap:ts:exemples}

\lstinputlisting{ts.R}


\section{Exercices}
\label{chap:ts:exercices}

\Opensolutionfile{reponses}[reponses-ts]
\begin{Filesave}{reponses}
\section*{Annexe \ref{chap:ts}}
\addcontentsline{toc}{section}{Annexe \protect\ref{chap:ts}}

\end{Filesave}

Avant de faire les exercices ci-dessous, importer dans \textsf{R} les
ensembles de données \texttt{deaths}, \texttt{strikes}, \texttt{uspop}
et \texttt{wine}. Utiliser pour ce faire les commandes suivantes:
<<echo=TRUE,eval=FALSE>>=
deaths <- ts(scan("deaths.dat", comment.char="#"), start=1973, frequency=12)
strikes <- ts(scan("strikes.dat", comment.char="#"), start=1951)
uspop <- ts(scan("uspop.dat", comment.char="#"), start=1790, deltat=10)
wine <- ts(scan("wine.dat", comment.char="#"), start=1980, frequency=12)
@

Il est possible d'afficher plus d'un graphique à la fois sur un
périphérique graphique en le subdivisant à l'aide des options
\argument{mfrow} (remplissage par ligne) et \argument{mfcol}
(remplissage par colonne) de la fonction \fonction{par}. Par exemple,
<<eho=TRUE,eval=FALSE>>=
par(mfrow=c(2, 1))
@
divisera la «page» en deux lignes et une colonne. Les deux prochains
graphiques se retrouveront donc l'un au-dessus de l'autre.

\begin{exercice}
  Exécuter les commandes \fonction{par} ci-dessous. Après chacune,
  exécuter les commandes suivantes pour constater l'effet de
  \code{par} sur le périphérique graphique:
<<echo=TRUE,eval=FALSE>>=
plot(deaths)
plot(strikes)
plot(uspop)
acf(wine)
@
  \begin{enumerate}
  \item \texttt{par(mfrow = c(2, 1))}
  \item \texttt{par(mfrow = c(1, 2))}
  \item \texttt{par(mfrow = c(2, 2))}
  \item \texttt{par(mfcol = c(2, 2))}
  \end{enumerate}
\end{exercice}

\begin{exercice}
  Simuler 100 observations des processus suivants.  Pour chacun,
  tracer sur un seul périphérique graphique le graphique de la série
  simulée ainsi que son corrélogramme (l'un au-dessus de l'autre).
  Comparer le corrélogramme à la fonction d'autocorrélation théorique.
  \begin{enumerate}
  \item $\{Z_t\} \sim \text{WN}(0, 2)$ où chaque $Z_t$ est une variable
    aléatoire normale de moyenne 0 et variance 2.
  \item $\{X_t\} \sim \text{MA}(1)$ avec $\theta = 0,8$ et $\sigma^2 =
    1$.
  \item $\{X_t\} \sim \text{MA}(1)$ avec $\theta = -0,6$ et $\sigma^2 =
    100$.
  \item $\{X_t\} \sim \text{MA}(2)$ avec $\theta_1 = 0,5$, $\theta_2
    = 0,4$ et $\sigma^2 = 1$.
  \item $\{X_t\} \sim \text{AR}(1)$ avec $\phi = 0,8$ et $\sigma^2 =
    1$.
  \item $\{X_t\} \sim \text{AR}(1)$ avec $\phi = -0,9$ et $\sigma^2 =
    100$.
  \item $\{X_t\} \sim \text{AR}(2)$ avec $\phi = 0,7$, $\phi_2 = -0,1$
    et $\sigma^2 = 1$.
  \end{enumerate}
  \SweaveOpts{echo=TRUE,eval=FALSE}
  \begin{rep}
    \begin{enumerate}
\item
<<>>=
arima.sim(100, model=list(sd=sqrt(2)))
@
\item
<<>>=
arima.sim(100, model=list(ma=0.8))
@
\item
<<>>=
arima.sim(100, model=list(ma=-0.6, sd=10))
@
\item
<<>>=
arima.sim(100, model=list(ma=c(0.5, 0.4)))
@
\item
<<>>=
arima.sim(100, model=list(ar=0.8))
@
\item
<<>>=
arima.sim(100, model=list(ar=-0.9, sd=10))
@
\item
<<>>=
arima.sim(100, model=list(ar=c(0.7, -0.1)))
@
    \end{enumerate}
  \end{rep}
\end{exercice}

\begin{exercice}
  Ajuster un modèle autorégressif pur aux données \texttt{lh} du
  package \texttt{MASS}\index{package!MASS@\texttt{MASS}} à l'aide de la
  fonction \fonction{ar}.
\end{exercice}

\begin{exercice}
  L'exercice suivant, bien qu'un peu artificiel, illustre la
  procédure d'analyse d'une série chronologique.
  \begin{enumerate}
  \item Simuler 100 valeurs d'un processus ARMA$(1, 1)$ avec $\phi =
    0,7$, $\theta = 0,5$ et $\sigma^2 = 1$.
  \item Tracer les graphiques suivants sur un même périphérique: la
    série, le corrélogramme et la fonction d'autocorrélation partielle
    empirique.
  \item Ajuster un modèle ARMA$(1, 1)$ aux données simulées au point
    a) en estimant les paramètres à l'aide de la fonction
    \fonction{arima}.  Les estimateurs devraient être près des valeurs
    utilisées lors de la simulation.
  \item Vérifier la qualité de l'ajustement du modèle obtenu en c) à
    l'aide de la fonction \fonction{tsdiag}.
  \item Prévoir les 12 prochaines valeurs du processus. Tracer un
    graphique de la série originale et des prévisions en fournissant
    les deux séries en argument à la fonction \fonction{ts.plot}.
  \end{enumerate}
\end{exercice}

\Closesolutionfile{reponses}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "exercices_methodes_statistiques"
%%% End:
